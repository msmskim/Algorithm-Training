# Intro
 'Hello Coding 그림으로 개념을 이해하는 알고리즘, 김도형, 한빛미디어' Chapter4 퀵 정렬을 읽고 정리한 글입니다.

# 분할 정복
 분할정복 전략 : 문제 해결 방법 중에서 가장 유명한 재귀적 기술
1. 가장 간단한 경우로 기본 단계를 찾습니다.
2. 주어진 문제를 작게 줄여서 기본 단계가 되도록 만드는 법을 찾아냅니다.

예) 2,4,6의 합계
def sum(arr):
  total = 0
  for x in arr:
    total += x
   return total
   
print(sum[1, 2, 3]))

# 퀵 정렬
선택 정렬보다 훨씬 빠르고 자주 사용됨

1. 원소가 하나인 배열이 기본 단계
def quicksort(array):
  if len(array) < 2:
    return array
    
2. 원소가 두개인 경우, 세개인 경우 늘려서 접근
3. 기준 원소를 정하고 그 보다 작은 원소와 큰 원소로 분류, 이것이 분할

# 빅오표기법 복습
이진 탐색 O(Log n)
단순 탐색 O(n)
퀵 정렬 O(nLogn)
선택 정렬 O(n^2)
외판원 문제 O(n!)

# 병합 정렬과 퀵 정렬 비교
1. 리스트에 있는 모든 원소를 출력하는 간단한 함수가 있다고 합시다.
def print_items(list):
  for item in list:
    print(item)
2. 1초 동아 대기
from time import sleep
def print_items2(list):
  for item in list:
    sleep(1)
    print(item)
3. 둘 다 O(n), 하지만 1이 더 빠름
4. c * n c는 상수임, 두개의 알고리즘이 서로 다른 표기법을 가지면 상수 무시
5. 하지만 같을경우 상수차이 때문에 발생하기도 함, 병합 정렬과 퀵 정렬이 그 예로 시간이 O(nLogn)으로 같다면, 퀵 정렬이 더 빠름

# 평균적인 경우와 최악의 경우 비교
1. 퀵 정렬의 성능은 기준 원소에 크게 의존, 만약 첫 번째 원소를 항상 기준 원소로 선택 그리고 이미 정렬되어 있는 배열에 대해 퀵 정렬을 호출, 이 경우
O(n)
2. 중간의 원소를 선택하는 경우 O(logn)
3. 스택의 첫번째 단계를 살펴보면, 기준 원소로 하나를 선택하면 나머지 원소들은 두 개의 하위 배열로 나뉘어짐, 이렇게 나누기 위해서는 8개 원소를 모두
기준 원소와 비교해야 함 O(n)
4. 그래서 최선의 경우 O(nlogn), 최악의 경우 O(n^2) 
5. 퀵 정렬에서는 일반적인 경우에도 최선의 경우와 같은 실행 속도를 가짐, 기준 원소를 전체 배열에서 무작위로 선택하면 퀵정렬은 평균적으로
O(nlogn) 실행시간을 가짐

# 출처
'Hello Coding 그림으로 개념을 이해하는 알고리즘, 김도형, 한빛미디어'
