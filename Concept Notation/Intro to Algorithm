Intro

'Hello Coding 그림으로 개념을 이해하는 알고리즘, 아디트야 바르가바, 김도형, MANNING, 한빛미디어'의
Chapter1 알고리즘의 소개를 읽고 개념을 정리한 글입니다.

# 이진탐색

1. 탐색문제
예) 전화번호부에서 누군가의 번호 찾기, 페이스북 로그인 시 페이스북이 정말 내아이디가 존재하나 찾는 것

2. 이진탐색
입력: 정렬된 원소 리스트

출력: 리스트에 원하는 원소가 있다면 그 원소의 위치, 없다면 Null

3. 단순탐색
예) 1~100까지의 범위에서 한 수를 찾을 때, 1부터 2, 3, 4 순으로 찾아 나가는 것

더 좋은 방법은 100의 중간 50부터 시작, 만약 50이 너무 작다는 답을 얻을 경우 절반을 걸러낼 수 있음

그 다음 51과 100의 중간인 75 순서

이것이 바로 이진탐색

이진 탐색을 n개의 원소를 가진 리스트에서 실행시 최대 logn번 만에 답 도출 가능, 지수 부분에 들어갈 값은 2

이진 탐색은 리스트의 원소들이 정렬되어 있어야 사용 가능

# 실행시간
1. 선형시간
추측해야 할 최대 횟수가 리스트의 길이와 같은 것 O(n)

2. 이진탐색
로그 시간으로 실행 O(Logn)

# 빅오표기법
1. 개념
알고리즘이 얼마나 빠른지 표시하는 특별한 방법

2. 알고리즘 실행 시간이 증가하는 속도가 다르면?
원소 수 증가 시 탐색시간의 증가 정도가 선형 탐색이 이진 탐색 보다 훨씬 큼

실행 시간만 고려하는 것이 아니라 리스트의 크기가 어떻게 증가하나 알아야 함

리스트의 크기가 n일 때, 단순 탐색은 n번 연산 O(n), 이진탐색은 logn번 연산 O(logn)

빅오 표기법은 최악의 경우를 나타낸 것으로, 이보다 더 느려지지 않는다는 보장이 주어짐

3. 많이 사용하는 빅오 실행시간의 예
O(logn), 로그시간, 예) 이진 탐색

O(n), 선형시간, 예) 단순 탐색

O(n * logn), 예) 퀵 정렬 같이 빠른 정렬 알고리즘

O(n**2), 예) 선택 정렬 같이 느린 정렬 알고리즘

O(n!) 예) 외판원 문제 같이 정말 느린 알고리즘

알고리즘의 속도는 시간이 아니라 연산 횟수가 어떻게 증가하는지로 측정

이렇게 하면 입력 데이터의 크기가 늘어날 때, 알고리즘의 실행 속도가 얼마나 증가하는지 알 수 있음

알고리즘의 실행 시간은 빅오 표기법으로 나타냄

O(logn)은 O(n)보다 빠르고, 찾으려는 리스트 원소 개수가 증가하면 상대적으로 더 빨라짐

# 외판원 문제
O(n!)의 실행시간을 가진 외판원 문제는 아직 풀지 못함

# 출처

Hello Coding 그림으로 개념을 이해하는 알고리즘, MANNING, 한빛미디어, 아디트야 바르가바, 김도형
